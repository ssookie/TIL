# 2부. 사용하기 좋은 API 디자인<br>>Chapter 05 "직관적인 API 디자인하기"

합의하기 나름이고
굳이? Error 코드를 나누는데 리소스가 많이 들게 하지 말자.
정상 응답 200 클라이언트 에러 400 서버 500 정도로만 나눠서... 응답에 대해서는 요청 자체의 문제가 있지 않는 경우는 보통 200을 내리는 경우도 있음.

개인적으로 사용처나
업무에 따라 다르다고 생각도 함...
외부에 범용적으로 사용하는 API의 경우에는 코드를 분기해서 내려주는 게 좋다고 생각하고
회사 내부에서 사용할 때에는 굳이 에러 

또한, 에러 케이스를 분기처리 하는 게.. 굳이 리소스를 들일 이유가 있나? 나누기 나름인뒈~~~~~~
예) 카카오의 경우 4XX, 5XX로만 나눠놓고 각





## 1. 직관적이고 간단한 표현 만들기

### 1.1 . 명확한 이름 정하기

* 약어를 피하기
* 이름을 정할 때는 (그 목적이 무엇이건) 세 단어에서 두 단어의 조합까지만 하기를 권한다.

### 1.2. 사용하기 쉬운 데이터 타입과 포맷 정하기

* API 가 사용하는 raw data는 개발자들이 명확하게 이해할 수 있어야 한다.
* 가능하다면, 단순히 읽기만 해도 이해할 수 있는 데이터 포맷이나 타입을 사용하는 것이 좋다.

### 1.3. 연관성이 있고 즉시 사용 가능한 데이터를 제공하여 컨슈머의 작업을 단순화한다.

* 명확하지 않은 데이터를 의미있는 데이터로 변경
* 데이터를 추가하여 암호화된 데이터를 설명
* 즉, 의미있는 데이터를 제공하여 사용성과 이해를 용이하게 한다.

## 2. 직관적인 상호작용

### 2.1. 직관적인 입력 요청하기

* 명확한 이름을 짓고, 모호한 약어는 피한다.
* 이해하기 쉬운 데이터 포맷을 사용한다.
* 데이터는 사용자가 입력하기 쉬워야 한다.

### 2.2. 발생 가능한 모든 에러 피드백을 식별하여, 각 에러를 유용하게 쓸 수 있도록 디자인 해야 한다.

* 규칙에 맞지 않는 에러(malformed rerquest error): 서버가 Request를 이해할 수 없는 경우에 발생
* 기능적 에러(functional error): 비즈니스의 구현 때문에 발생함
* 서버 에러(server error): 서버의 장애나 구현의 버그로 인한 문제

### 2.3. 유용한 에러 피드백 반환하기

* API의 에러 피드백은 최대한 유용한 정보를 제공해야 한다.
* 에러 피드백은 반드시 컨슈머에게 무엇이 문제인지 알려주어야 하고, 컨슈머가 곧바로 해결할 수 있는 데 도움이 되는 정보를 제공해야 한다.

#### 1) [HTTP 상태 코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

* 1xx (정보): 요청을 받았으며 프로세스를 계속한다.
* 2xx (성공): 요청을 성공적으로 받았으며 인식했고 수용하였다.
* 3xx (리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요하다.
* 4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다.
* 5xx (서버 오류): 서버가 명백히 유효한 요청에 대해 충족을 실패했다.

#### 2) 정밀한 에러 피드백 & 규격에 맞지 않는 Request 에러와 기능적 에러에 대한 HTTP 상태 코드

* 400(잘못된 요청): 서버가 요청의 구문을 인식하지 못했다.
* 403(Forbidden, 금지됨): 서버가 요청을 거부하고 있다. 
* 404(Not Found, 찾을 수 없음): 서버가 요청한 페이지(Resource)를 찾을 수 없다. 예를 들어 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.
* 409(충돌): 서버가 요청을 수행하는 중에 충돌이 발생했다. 서버는 응답할 때 충돌에 대한 정보를 포함해야 한다. 서버는 PUT 요청과 충돌하는 PUT 요청에 대한 응답으로 이 코드를 요청 간 차이점 목록과 함께 표시해야 한다.
* 500(내부 서버 오류): 서버에 오류가 발생하여 요청을 수행할 수 없다.

|Use Case|사용 예|HTTP 상태 코드|
|--|--|--|
|잘못된 파라미터|GET /accounts/123 Request에 존재하지 않는 계좌에 대해서 조회|404 Not Found|
|필수 속성의 누락|amount가 누락됨|400 Bad Request|
|잘못된 데이터 타입|"startDate": 1423332060|400 Bad Request|
|기능적 에러|금액이 소비 한도를 초과|403  Forbidden|
|기능적 에러|보내는 계좌에서 받는 계좌로의 이체가 금지됨|403 Forbidden|
|기능적 에러|지난 5분 이내에 동일한 송금이 발생한 전력이 있음|409 Conflict|
|예상치 못한 서버 에러|구현에 버그가 숨겨져 있음|500 Internal Server Error|

#### 3) 상세한 에러 리스폰스 제공

* HTTP 상태 코드만으로는 문제 해결에 필요한 모든 정보를 제공할 수 없어, 에러 메시지를 Response Body에 포함해서 제공해야 할 필요가 있다.
* 에러를 정의할 때 에러마다 특정 타입을 정의할 필요는 없고, 포괄적인 타입(generic type)을 정의하는 것이 좋다.

```json
# 속성이 하나라도 없을 때, MISSING_MANDATORY_PROPERTY를 사용
{
    "source": "amount",
    "type": "MISSING_MANDATORY_PROPERTY",
    "message": "금액은 필수입니다."
}
```

* [JSON path](https://goessner.net/articles/JsonPath/) 같은 것을 추가하여, 에러 발생 지접을 알려 주는 구체적인 에러 리스폰스를 제공할 수 있다. (내부 노드들의 위치 표현)

```json
# 필수 항목인 firstname이 소유자 리스트의 첫번째 아이템에서 누락되어 있는 경우, Json path로 해당 아이템의 위치를 표현할 수 있다.
{
    "source": "firstname",
    "path": "$.owners[0].firstname",
    "type": "MISSING_MANDATORY_PROPERTY",
    "message": "Firstname is mandatory"
}
```

### 2.4. 철저한 에러 피드백 반환하기

* 한 번의 에러 피드백에 최대한 많이 포함해 전달해야 한다.
* 애러 피드백은 가능할 철저하게 제공한다.

```json
# 404 Bad Request
# 규격에 맞지 않는 리퀘스트 에러 두 개를 에러 목록 하나에 포함시켜 반환해야 한다.
{
    "message": "Invalid Request",
    "errors": [
        {
            "source": "amount",
            "type": "MISSING_MANDATORY_PROPERTY",
            "message": "Amount is mandatory."
        },
        {
            "source": "destination",
            "type": "MISSING_MANDATORY_PROPERTY",
            "message": "Destination is mandatory."
        }
    ]
}
```

* 여러 개의 에러를 하나의 피드백 메시지로 그룹화를 통해 상호작용을 단순화하는 것은 리퀘스트/에러 사이클의 횟수를 줄여준다.

### 2.5. 유용한 성공 피드백 받기 (유용한 피드백 메시지가 포함되어야 함)

* 200(성공): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
* 201(작성됨): 성공적으로 요청되었으며 서버가 새 리소스를 작성했다.
* 202(허용됨): 서버가 요청을 접수했지만 아직 처리하지 않았다.

|Use Case|사용 예|HTTP 상태 코드|
|--|--|--|
|즉시 이체 성공|송금에 대한 요청이 즉시 처리되었음.|201 Created HTTP|
|예약 이체|요청은 접수되었지만 수행은 아직 되지 않았음.|202 Accepted|
|자동 이체|컨슈머에세 송금이 필요한 시기에 수행된 예정.|202 Accepted|

* 성공 피드백은 무슨 일이 벌어졌는지, 그 다음에 무엇을 해야 하는지에 대한 정보를 제공해 주는 것이 좋다.

## 3. 직관적인 흐름

* 에러 방지를 위해, 데이터나 새로운 목표를 추가하여 목표 흐름(Flow)를 최적화 할 수 있다.

### 3.1. 직관적인 목표 연쇄 만들기

* 유용하고 철저한 에러 피드백을 통해, 리퀘스트/에러로 인한 사이클을 줄이고 인위적으로 API 호출의 연쇄가 길어지는 것을 예방할 수 있다.

### 3.2. 에러 방지

* 가능한 오류를 분석하여, 이를 예방할 수 있는 추가 값 데이터를 결정한다.
* 기존 목표의 성공 피드백을 향상시켜 이러한 데이터를 제공한다.
* 이러한 데이터를 제공하기 위한 새로운 목표를 수립한다.

### 3.3. 목표 통합

* 예) 송금 시, 보내는 계좌 목록/받는 계좌 목록을 각각 조회 → 한 번의 호출로 보내는 계좌/받는 계좌 목록을 조회
* 직관적인 흐름이나, 이런 통합은 성능적인 이슈를 발생시킬 수도 있다.

### 3.4. 상태가 없는 흐름 디자인하기

* REST 제약사항: 상태 없음(Stateless)
    * 서버와 리퀘스트 사이에 (세션 등을 통해) 중간에 젖아하는 컨텍스트가 존재하지 않아야 한다.
    * 리퀘스트는 오직 리퀘스트가 제공하는 정보를 통해서만 처리되어야 한다.
    * 세션에 해당 정보를 들고 있는 특정 인스턴스만이 리퀘스트를 처리하는 방법과는 다르게, 여러 대의 인스턴스 중 어떤 인스턴스에서나 리퀘스트를 처리할 수 있게 한다.
    * API 목표를 독립적으로 사용할 수 있게 하여, 다른 컨텍스트에서도 얼마든지 해당 API를 재사용할수 있게 한다.
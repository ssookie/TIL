# [Chapter 02 "TDD 시작"](https://github.com/bakery-blueprint/sandwich-tdd/blob/master/docs/1%EC%A3%BC%EC%B0%A8/ch02_TDD%EC%8B%9C%EC%9E%91.md)

## 1. TDD 이전의 개발

### 개발 과정 :

1. **설계**를 통해 인터페이스와 클래스, 메서드를 도출한다.
2. **구현 코드를 한 번에 작성**한다.
3. 구현 완료 후 수동으로 기능을 **테스트**한다.
4. 원하는 대로 동작 하지 않거나 문제가 발생하면 **디버깅**을 통해 원인을 파악하고 수정한다.
5. 3, 4의 과정을 개발이 완료될 때까지 **반복**한다.

### 문제점 :

1. **한 번에 작성하는 코드가 많다.**
    - 문제 발생시 원인을 파악하기 위해 확인해야 하는 코드량이 많다.
    - 디버깅 하는 시간이 길어진다. (최초에 코드를 작성하는 시간보다 디버깅 시간이 길어지기도 한다.)
2. **코드를 작성하는 개발자와 코드를 테스트하는 개발자가 다른 경우가 많다.**
    - 코드 작성 시점과 코드 테스트 시점이 다를 확률이 높다.
    - 다른 개발자가 과거에 작성한 코드를 모두 살펴보며 디버깅 해야 하므로 공수가 많이 든다.
3. **테스트 환경을 구성하기 쉽지 않다.**
    - WAS나 DB 등을 구동하는 데에 시간이 소모된다.
    - 테스트를 위한 사전 조건을 구성하는 과정이 복잡하다.


> 한 번에 구현하는 코드가 많을 수록, 한 번에 구현하는 시간이 길어질 수록 디버깅 난이도가 높아진다.
>

## 2. TDD란?

> 기능이 올바르게 동작하는지 검증하는 테스트 코드를 먼저 작성하고, 작성한 테스트를 통과시키기 위한 구현을 작성하는 개발 방식
>

### TDD 이점

1. 온전하게 동작한다는 것을 `검증`해주는 테스트가 있으므로 코드 수정에 대한 `심리적 불안감`을 줄여준다.
2. 지속적으로 코드 정리를 하므로, 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있다.
3. 새로운 코드를 추가하거나, 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인할 수 있다.

### **구체적인 TDD 수행 절차** :

1. **테스트할 대상과 케이스를 선택**한다.
2. 해당 케이스에 대한 **테스트 코드를 작성**한다.
3. 컴파일 오류를 없애는 데 필요한 **구현 요소들(클래스, 메서드 등)을 추가**한다.
4. 테스트를 실행하여 **실패하는 것을 확인**한다.
5. 테스트를 통과시킬 만큼만 **구현 코드를 추가**한다.
6. 테스트를 통과했다면 구현 코드와 테스트 코드에 개선할 코드가 있는지 확인 후 **리팩토링**한다.
7. **리팩토링 이후에도 모든 테스트를 통과하는지 확인**한 후 마무리한다.
8. **새로운 케이스를 선택**한 후 2 ~ 7의 **과정을 반복하면서 점진적으로 기능을 완성**해 나간다.

> 단언(Assertion)이란? <br>
> - 값이 특정 조건을 충족하는지 확인하고, 충족하지 않는 경우 예외(Exception)를 발생
> - 테스트 메서드 내의 단언에서 예외가 발생하는 것을 "테스트에 실패했다"고 한다.
>

### **TDD 사이클 :**

- **테스트 작성 - 개발 - 리팩토링**을 반복하는 사이클
- **Red(실패) - Green(성공) - Refactor** 로 부르기도 한다.

## **테스트 코드의 작성 위치**

- 테스트 코드는 `src/test/java` 소스 폴더에 작성한다.
- `src/test/java` 소스 폴더는 배포 대상이 아니므로 해당 폴더에 코드를 만들면 완성되지 않은 코드가 배포되는 것을 방지하는 효과가 있다.
- 개발이 완료되면 구현 소스 코드를 `src/main/java` 소스 폴더로 이동한다.
- 테스트 코드에서 사용하는 파일은 `src/test/resources` 폴더에 보관하고, 소스 코드 리포지토리에 함께 업로드 해야 한다.

## 간단한 예시 - 덧셈 기능 구현

```java
package chap02;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    @Test
    void plus() {
        int result = Calculator.plus(1, 2);
        assertEquals(3, result);
        assertEquals(5, Calculator.plus(4, 1));
    }
}
```

- @Test : JUnit은 @Test 어노테이션을 붙인 메소드를 테스트 메소드로 인식
- assertEquals() : 파라미터로 받은 두 값이 동일한지 비교

```java
package chap02;

public class Calculator {
    public static int plus(int a1, int a2) {
        return a1 + a2;
    }
}
```

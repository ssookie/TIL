# Chapter 04 "카프카 컨슈머: 카프카에서 데이터 읽기"

## 1. 카프카 컨슈머의 주요 개념

### 1.1. 컨슈머와 컨슈머 그룹

* 카프카 컨슈머들은 컨슈머 그룹(consumer group)에 속한다.
* 다수의 컨슈머가 같은 토픽을 소비하면서 같은 컨슈머 그룹에 속할 때는 각 컨슈머가 해당 토픽의 서로 다른 파티션을 분담해서 메시지를 읽는다.
* 활용
    * 하나의 컨슈머 그룹에 더 많은 컨슈머를 추가하면 카프카 토픽의 데이터 소비를 확장할 수 있다.
        * 대기 시간이 긴 작업을 수행하는 카프카 컨슈머에 많이 사용된다. (하나의 컨슈머로는 토픽의 데이터 추가 속도를 따라 잡을 수 없음)
    * 각 컨슈머가 여러 파티션을 분담하여 작업량을 공유하도록 더 많은 컨슈머를 추가하는 것이 소비 확장에 도움이 된다.
        * 반대로 많은 수의 파티션을 갖도록 토픽을 생성하는 이유이기도 하다. (작업량이 증가할 때 더많은 컨슈머를 추가할 수 있음)

### 1.2. 컨슈머 그룹과 리밸런싱

## 2. 카프카 컨슈머 생성하기

## 3. 토픽 구독하기

## 4. 폴링 루프

* 컨슈머의 토픽 구독 요청이 정상적으로 처리되면, 서버로부터 연속적으로 많은 데이터를 읽기 위해 폴링(polling) 하는 루프에서 데이터를 읽는 데 필요한 모든 상세 작업을 처리한다.
* 세션 타임아웃과 이에 따른 리밸런싱을 방지하는 데 충분한 시간 간격으로 컨슈머가 poll() 메서드를 호출해야 한다.

## 5. 컨슈머 구성하기 (컨슈머 매개변수)

* fetch.min.bytes
    * 레코드를 가져올 때, 브로커로부터 받기 원하는 데이터의 최소량(바이트)를 지정
    * 지정한 사이즈보다 작은 경우, 브로커는 더 많은 메시지가 모일 때까지 기다렸다가 컨슈머에게 전송한다.
* fetch.max.wait.ms
    * 기다리는 시간 제어
    * 만약 fetch.max.wait.ms 가 100밀리초/fetch.min.bytes가 1MB 로 설정하면, 카프카는 둘중 한 조건을 만족할 때 데이터를 전송한다.
* max.partition.fetch.bytes
    * 서버가 파티션당 반환하는 최대 바이트 수를 제어한다.
    * 컨슈머의 poll() 메서드에서 ConsumerRecords 객체를 반환할 때, 그 컨슈머에 할당된 파티션당 최대 이 설정값 까지를 레코드 객체가 사용할 수 있다.
* session.timeout.ms
    * 브로커가 컨슈머가 살아있는 것으로 판단하는 시간 (기본값 10초)
    * 이 시간이 경과되면, 컨슈머 그룹의 리밸런싱을 시작한다.
* auto.offset.reset
    * 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우에, 컨슈머가 어떤 레코드를 읽게 할 것인지 제어
    * earliest : 가장 초기의 오피셋 값으로 설정
    * latest : 가장 마지막의 오프셋 값으로 설정 
    * none : 이전 오프셋값을 찾지 못하면 에러
* enable.auto.commit
    * 백그라운드로 주기적으로 오프셋을 커밋
* partition.assignment.strategy
    * 파티션 할당 전략을 지정한다.
    * RangeAssignor
        * 컨슈머들이 구독하는 모든 토픽의 파티션들을 각 컨슈머마다 연속적으로 할당한다. <br>
        (파티션을 숫자 순서로 놓고 컨슈머는 사전순으로 놓은 후, 연속적으로 할당한다.)
        ```
        컨슈머 C0,C1 / 토픽 t0, t1 / 각 토픽이 3개의 파티션을 가짐 
        -> 결과: t0p0, t0p1, t0p2, t1p0, t1p1, and t1p2
        C0: [t0p0, t0p1, t1p0, t1p1]<br>
        C1: [t0p2, t1p2]
        ```
    * RoundRobinAssignor
        * 구독하는 모든 토픽의 모든 파티션들을 컨슈머들에게 하나씩 번갈아 차례대로 할당한다.
        ```
        C0: [t0p0, t0p2, t1p1]
        C1: [t0p1, t1p0, t1p2]
        ```
* client.id
    * 클라리언트로부터 전송된 메시지 (로그와 메트릭 데이터)를 식별하기 위해 브로커가 사용
* max.poll.records
    * 한번의 poll() 메서드 호출에서 반환되는 레코드의 최대 개수를 제어한다.
    * 애플리케이션이 처리해야 하는 데이터의 양을 처리할 때 유용하다.
* recieve.buffer.bytes / send.buffer.bytes
    * 데이터를 읽거나 쓸 때 소켓이 사용하는 TCP 송수신 버퍼의 크기를 제어한다.

## 6. 커밋과 오프셋

## 7. 리밸런싱 리스너

## 8. 특정 오프셋을 사용해서 레코드 소비하기

## 9. 어떻게 폴링 루프를 벗어나야 할까?

## 10. 역직렬처리기

## 11. 독자 실행 컨슈머: 그룹 없이 하나의 컨슈머만 사용하는 이유와 방법

## 12. 구버전의 컨슈머 API들
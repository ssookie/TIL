
----------------------------------------
-- 실습 2-1. 인덱스 튜닝  
----------------------------------------

-- A. 실습 준비 

-- 테이블 생성(TB_CUST 테이블과 TB_ORD 테이블의 관계는 1:M 이다.)

CREATE TABLE TB_CUST 
(
    CUST_ID VARCHAR2(10), --고객ID
    CUST_NM VARCHAR2(50), --고객명
    BIRTH_DT VARCHAR2(8), --생일
    INST_DT VARCHAR2(8), --입력일자
    INST_ID VARCHAR2(10), --입력자ID
    INST_NM VARCHAR2(50) --입력자명
);

CREATE TABLE TB_ORD
(
    ORD_NO VARCHAR2(15), --주문번호
    ORD_DT VARCHAR2(8), --주문일자
    PRDT_CD VARCHAR2(6), --제품코드
    ORD_AMT NUMBER(15), --주문금액
    DIS_AMT NUMBER(15), --할인금액
    INST_DT VARCHAR2(8), --입력일자
    INST_ID VARCHAR2(10), --입력자ID
    INST_NM VARCHAR2(50), --입력자명
    CUST_ID VARCHAR2(10) --고객ID
);

-- 데이터 입력

ALTER TABLE TB_CUST NOLOGGING; 

INSERT INTO TB_CUST --고객테이블
SELECT
    LPAD(TO_CHAR(ROWNUM), 10, '0'), --고객ID
    DBMS_RANDOM.STRING('U', 10), --고객명
    TO_CHAR(SYSDATE-TRUNC(DBMS_RANDOM.VALUE(365,36500)), 'YYYYMMDD'), --생일
    TO_CHAR(SYSDATE, 'YYYYMMDD'), --입력일자
    'SQLSTUDY', --입력자ID
    'ssookie'  --입력자명
FROM DUAL CONNECT BY LEVEL <= 100000
;


INSERT /*+ APPEND */ INTO TB_ORD --APPEND힌트 사용, 주문 테이블 
SELECT
  LPAD(TO_CHAR(ROWNUM), 15, '0'),--주문번호
  TO_CHAR(SYSDATE-TRUNC(DBMS_RANDOM.VALUE(365,3650)), 'YYYYMMDD'), --주문일자
  DBMS_RANDOM.STRING('X', 6), --제품코드
  TRUNC(DBMS_RANDOM.VALUE(1000, 100000)), --주문금액
  TRUNC(DBMS_RANDOM.VALUE(100, 10000)), --할인금액
  TO_CHAR(SYSDATE, 'YYYYMMDD'), --입력일자
  'SQLSTUDY', --입력자ID
  'ssookie',  --입력자명
  A.CUST_ID--고객ID
FROM TB_CUST A, ( SELECT LEVEL FROM DUAL CONNECT BY LEVEL <= 10);


-- 기본키 생성

ALTER TABLE TB_CUST
ADD CONSTRAINT TB_CUST_PK 
PRIMARY KEY (CUST_ID);

ALTER TABLE TB_ORD
ADD CONSTRAINT TB_ORD_PK
PRIMARY KEY (ORD_NO);

-- 외래키 생성

ALTER TABLE TB_ORD
ADD CONSTRAINT TB_ORD_FK
FOREIGN KEY (CUST_ID) REFERENCES TB_CUST(CUST_ID);

-- 통계 정보 생성 

ANALYZE TABLE TB_CUST COMPUTE STATISTICS
FOR TABLE FOR ALL INDEXES FOR ALL INDEXED COLUMNS SIZE 254;

ANALYZE TABLE TB_ORD COMPUTE STATISTICS
FOR TABLE FOR ALL INDEXES FOR ALL INDEXED COLUMNS SIZE 254;

-- B. 튜닝 전 SQL 문

SELECT 	/*+ FULL(A) */
   		COUNT(*) -- SORT AGGREGATE
FROM 	TB_CUST A
WHERE	A.CUST_NM LIKE 'AB%' 
AND		EXISTS
    	(
        SELECT	'1'
        FROM 	TB_ORD C
        WHERE	C.CUST_ID = A.CUST_ID 
        AND		C.PRDT_CD LIKE 'AB%'
     )
;

-- C. 튜닝

-- 인덱스 생성 

CREATE INDEX TB_CUST_IDX01 ON TB_CUST(CUST_NM);
CREATE INDEX TB_ORD_IDX01 ON TB_ORD(CUST_ID, PRDT_CD);

-- 통계정보 생성

ANALYZE INDEX TB_CUST_IDX01 COMPUTE STATISTICS;
ANALYZE INDEX TB_ORD_IDX01 COMPUTE STATISTICS;

-- 튜닝 후 SQL 문

SELECT	/*+ INDEX(A TB_CUST_IDX01) */
 		COUNT(*)
FROM 	TB_CUST A
WHERE 	A.CUST_NM LIKE 'AB%'
AND 	EXISTS
        (
        SELECT	/*+ INDEX(C TB_ORD_IDX01) NL_SJ */ 
                '1'
        FROM 	TB_ORD C
        WHERE 	C.CUST_ID = A.CUST_ID
        AND 	C.PRDT_CD LIKE 'AB%'
        )
;

-- 추가 인덱스 튜닝

DROP INDEX TB_CUST_IDX01;
CREATE INDEX TB_CUST_IDX01 ON TB_CUST(CUST_NM, CUST_ID);
ANALYZE INDEX TB_CUST_IDX01 COMPUTE STATISTICS;

----------------------------------------
-- 실습 2-2. 인덱스 구성 컬럼을 추가하여 테이블 랜덤 액세스를 제거하자
----------------------------------------

-- A. 실습 준비 

-- 테이블 생성

DROP TABLE TB_ORD;
CREATE TABLE TB_ORD
(
    ORD_NO VARCHAR2(10), --주문번호
    ORD_DT VARCHAR2(8), --주문일자
    ORD_NM VARCHAR2(150), --주문이름
    ORD_AMT NUMBER(15), --주문금액
    PRDT_CD VARCHAR2(6), --상품코드
    SALE_GB VARCHAR2(2), --판매구분
    PAY_GB VARCHAR2(2), --결제구분
    CUST_ID VARCHAR2(10), --고객ID
    INST_DTM DATE, --입력시간
    INST_ID VARCHAR2(50), --입력자ID
    UPDT_DTM DATE, --수정시간
    UPDT_ID VARCHAR2(5) --수정자ID
);

CREATE TABLE DUAL_5 -- 데이터 복제에 이용하기 위함. 
(
    DUMMY VARCHAR2(1)
);

-- 데이터 INSERT

INSERT INTO DUAL_5
SELECT DUMMY
FROM DUAL CONNECT BY LEVEL <= 5;

ALTER TABLE TB_ORD NOLOGGING;

INSERT /*+ APPEND */  INTO TB_ORD --APPEND 힌트 사용
SELECT
    LPAD(TO_CHAR(ROWNUM), 10, '0'),
    TO_CHAR(SYSDATE-TRUNC(DBMS_RANDOM.VALUE(1,3650)), 'YYYYMMDD'),
    DBMS_RANDOM.STRING('U', 150),
    TRUNC(DBMS_RANDOM.VALUE(1000, 100000)),
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 50)), 6, '0'),
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 10)), 2, '0'),
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 10)), 2, '0'),
    LPAD(TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1, 100000))), 10, '0'),
    SYSDATE,
    'SQLSTUDY',
    NULL,
    NULL
FROM DUAL_5, (SELECT LEVEL LV FROM DUAL CONNECT BY LEVEL <= 100000);

-- 기본키 생성

ALTER TABLE TB_ORD
ADD CONSTRAINT TB_ORD_PK 
PRIMARY KEY (ORD_NO);

-- 인덱스 구성

CREATE INDEX TB_ORD_IDX01 ON TB_ORD(ORD_DT, ORD_NM, ORD_AMT);

-- 통계정보 생성 

ANALYZE TABLE TB_ORD COMPUTE STATISTICS
FOR TABLE FOR ALL INDEXES FOR ALL INDEXED COLUMNS SIZE 254;

-- B. 튜닝 전 SQL 문 

SELECT	ORD_DT
      , SALE_GB
      , PAY_GB
      , Count(*)               AS 주문건수
      , Sum(ORD_AMT)           AS 총주문금액
      , Round(Avg(ORD_AMT), 2) AS 평균주문금액
FROM	TB_ORD
WHERE	ORD_DT BETWEEN '20150101' AND '20151231'
AND 	ORD_NM LIKE 'A%'
AND 	ORD_AMT >= 1000
GROUP  	BY 
		ORD_DT
      , SALE_GB
      , PAY_GB
ORDER  	BY 
		ORD_DT
      , SALE_GB
      , PAY_GB
; 

-- C. 튜닝

-- 인덱스 추가 

CREATE INDEX TB_ORD_IDX02 ON TB_ORD(ORD_DT, ORD_NM, ORD_AMT, SALE_GB, PAY_GB);
ANALYZE INDEX TB_ORD_IDX02 COMPUTE STATISTICS;

-- 데이터 조회 

SELECT	/*+ INDEX(TB_ORD TB_ORD_IDX02) */
		ORD_DT
      , SALE_GB
      , PAY_GB
      , Count(*)               AS 주문건수
      , Sum(ORD_AMT)           AS 총주문금액
      , Round(Avg(ORD_AMT), 2) AS 평균주문금액
FROM	TB_ORD
WHERE	ORD_DT BETWEEN '20150101' AND '20151231'
AND 	ORD_NM LIKE 'A%'
AND 	ORD_AMT >= 1000
GROUP  	BY 
		ORD_DT
      , SALE_GB
      , PAY_GB
ORDER  	BY 
		ORD_DT
      , SALE_GB
      , PAY_GB
; 

----------------------------------------
-- 실습 2-3. 인덱스 패스트 풀 스캔을 활용하여 집계 쿼리하기. 
----------------------------------------

-- A. 실습 준비

-- 테이블 생성 

CREATE TABLE TB_SUPP
(
	SUPP_NO VARCHAR2(10), --공급업체번호
	SUPP_NM VARCHAR2(50), --공급업체명
	INST_DT VARCHAR2(8), --가입일자
	INST_TM VARCHAR2(6), --가입시간
	INST_ID VARCHAR2(50) --입력자ID
);

CREATE TABLE DUAL_1000 -- 데이터 복제에 이용 
(
DUMMY CHAR(1)
);

INSERT INTO DUAL_1000
SELECT DUMMY FROM DUAL CONNECT BY LEVEL <= 1000;

COMMIT;

ALTER TABLE TB_SUPP NOLOGGING;

INSERT /*+ APPEND */ INTO TB_SUPP --APPEND 힌트 사용
SELECT
	LPAD(TO_CHAR(ROWNUM), 10, '0'),
	DBMS_RANDOM.STRING('U', 50),
	TO_CHAR(SYSDATE - DBMS_RANDOM.VALUE(1, 3650), 'YYYYMMDD'),
	TO_CHAR(SYSDATE - DBMS_RANDOM.VALUE(1, 86400)/24/60/60, 'HH24MISS'),
	'SQLSTUDY'
FROM DUAL_1000, (SELECT LEVEL LV FROM DUAL CONNECT BY LEVEL <= 10000);

-- 기본키 생성 

ALTER TABLE TB_SUPP
ADD CONSTRAINT TB_SUPP_PK
PRIMARY KEY (SUPP_NO);

-- 인덱스 생성 

CREATE INDEX TB_SUPP_IDX01 ON TB_SUPP(INST_DT);

-- 통계정보 생성 

ANALYZE TABLE TB_SUPP COMPUTE STATISTICS
FOR TABLE FOR ALL INDEXES FOR ALL INDEXED COLUMNS SIZE 254;

-- B. 튜닝 전 SQL 문 

SELECT	/*+ INDEX(TB_SUPP TB_SUPP_IDX01) */
		SUBSTR(INST_DT, 1, 6)
	  , COUNT(*)
FROM 	TB_SUPP
WHERE 	INST_DT BETWEEN TO_CHAR(SYSDATE - 365, 'YYYYMMDD') AND TO_CHAR(SYSDATE, 'YYYYMMDD')
AND 	SUPP_NM LIKE '%A%'
GROUP 	BY 
		SUBSTR(INST_DT, 1, 6)
;

-- C. 튜닝 

-- 인덱스 추가 

CREATE INDEX TB_SUPP_X02 ON TB_SUPP(INST_DT, SUPP_NM);
ANALYZE INDEX TB_SUPP_X02 COMPUTE STATISTICS;

-- 데이터 조회 

SELECT	/*+ INDEX_FFS(TB_SUPP TB_SUPP_IDX02) */
		SUBSTR(INST_DT, 1, 6)
	  , COUNT(*)
FROM 	TB_SUPP
WHERE 	INST_DT BETWEEN TO_CHAR(SYSDATE - 365, 'YYYYMMDD') AND TO_CHAR(SYSDATE, 'YYYYMMDD')
AND 	SUPP_NM LIKE '%A%'
GROUP 	BY 
		SUBSTR(INST_DT, 1, 6)
;

----------------------------------------
-- 실습 2-4. 테이블 풀 스캔을 유도하여 비효율적인 인덱스 스캔을 예방하자. 
----------------------------------------

-- A. 실습 준비 

-- 테이블 생성 

CREATE TABLE TB_ORD
(
    ORD_NO VARCHAR2(10), --주문번호
    ORD_DT VARCHAR2(8), --주문일자
    ORD_NM VARCHAR2(150), --주문이름
    ORD_AMT NUMBER(15), --주문금액
    PRDT_CD VARCHAR2(6), --상품코드
    SALE_GB VARCHAR2(2), --판매구분
    PAY_GB VARCHAR2(2), --결제구분
    CUST_ID VARCHAR2(10), --고객ID
    INST_DTM DATE, --입력시간
    INST_ID VARCHAR2(50), --입력자ID
    UPDT_DTM DATE, --수정시간
    UPDT_ID VARCHAR2(5), --수정자ID
);


CREATE TABLE DUAL_1000 -- 데이터 복제를 위한 테이블 
(
DUMMY CHAR(1)
);

INSERT INTO DUAL_1000
SELECT DUMMY FROM DUAL CONNECT BY LEVEL <= 1000;

COMMIT;

ALTER TABLE TB_ORD NOLOGGING;

INSERT /*+ APPEND */  INTO TB_ORD -- APPEND 힌트 사용
SELECT
    LPAD(TO_CHAR(ROWNUM), 10, '0'),
    TO_CHAR(SYSDATE-TRUNC(DBMS_RANDOM.VALUE(1, 3650)), 'YYYYMMDD'),
    DBMS_RANDOM.STRING('U', 150),
    TRUNC(DBMS_RANDOM.VALUE(1000, 100000)),
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 50)), 6, '0'),
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 3)), 2, '0'), -- SALE_GB (00, 01, 02 3개 중 하나의 값) / 선택도 33.3%
    LPAD(TO_CHAR(MOD(TRUNC(DBMS_RANDOM.VALUE(1, 1000)), 10)), 2, '0'),
    LPAD(TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(1, 100000))), 10, '0'),
    SYSDATE,
    'SQLSTUDY',
    NULL,
    NULL
FROM DUAL_1000, (SELECT LEVEL LV FROM DUAL CONNECT BY LEVEL <= 10000);

-- 기본키 생성 

ALTER TABLE TB_ORD
ADD CONSTRAINT TB_ORD_PK 
PRIMARY KEY(ORD_NO);

-- 선택도 

SELECT
ROUND(1/COUNT(DISTINCT SALE_GB) * 100, 2) 선택도
FROM TB_ORD;

-- 인덱스 생성 

CREATE INDEX TB_ORD_IDX01 ON TB_ORD(SALE_GB);

-- 통계정보 생성 

ANALYZE TABLE TB_ORD COMPUTE STATISTICS
FOR TABLE FOR ALL INDEXES FOR ALL INDEXED COLUMNS SIZE 254;

-- B. 튜닝 전 SQL 문

SELECT	/*+ INDEX(TB_ORD TB_ORD_IDX01) */
		*		
FROM 	TB_ORD
WHERE 	SALE_GB IN ('01', '02')
;

-- C. 튜닝 후 SQL 문 

SELECT	/*+ FULL(TB_ORD) */
		*
FROM 	TB_ORD
WHERE 	SALE_GB IN ('01', '02')
;



